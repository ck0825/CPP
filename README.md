# 〇、C++相关概念

- C++融合了3种不同的编程方式：<font color=blue>C语言代表的过程性语言、</font><font color=red>C++在C语言基础上添加的类代表的面向对象语言、C++模版支持的泛型编程。</font>

- 面向对象编程，Object Oriented Programming (OOP)。

  <p style="color:red;background-color:gray;text-align:center;">OOP的本质是设计并扩展自己的数据类型。</p>
  
- 面向过程编程强调的是算法，OOP强调的是数据；
  
- 在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构；
  
  通常，<font color=blue>类规定了可以使用那些数据来表示对象以及可以对这些数据进行哪些操作；</font>
  
  - 类是用户定义的一种数据类型。要定义类，需要描述<font color=red>它能够表示什么信息</font>和<font color=red>可对数据执行哪些操作；</font>
  - 类定义描述的是数据格式及其用法，而对象则是根据数据格式规范创建的实体。
  
- <font color=blue>类之于对象就像类型之于变量，即类定义描述的是数据格式机器用法，而对象则是根据数据格式规范创建的实体。</font>
  
- 泛型编程，Generic programming, 是C++支持的另一种编程模式。

  - <font color=blue>OOP强调的是编程的数据方面，泛型编程强调的是独立于特定数据类型；</font>
  - 他们的侧重点不同，OOP是一个管理大项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具。

- C++的语句
  - 声明语句：定义函数中使用的变量的名称和类型；
  - 赋值语句：使用赋值运算符号(=)给变量赋值；
  - 消息语句：将消息发给对象，激发某种行为；
  - 函数调用：执行函数。被调用的函数执行完毕后，程序将返回到调用语句后面的语句；
  - 函数原型：声明函数的返回类型，函数接受的参数数量和类型。
  - 返回语句：将一个值从被调用的函数那里返回到调用函数中。



# 一、处理数据

<font color=blue>面向对象编程(OOP)的本质就是设计并扩展自己的数据类型。</font>

内置的C++数据类型分两组：基本类型和复合类型。

- 基本类型：<font color=red>整数和浮点型；</font>
- 复合类型：<font color=red>数组、字符串、指针和结构。</font>

## 1.1 简单变量

**为把信息存储在计算机中，程序必须记住3个基本属性**

- <font color=red>信息将存储在哪里；</font>
- <font color=red>要存储什么值；</font>
- <font color=red>存储何种类型的值。</font>

1. **变量名**
   - C++提倡用有一定含义的变量名。
   - 命名规则：
     - 在名称中只能使用字母字符、数字和下划线；
     - 名称的第一个字符不能是数字；
     - 区分大写字符和小写字符；
     - 不能将C++的关键字作名称；
     - <font color=blue>以两个下划线或下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)使用；</font>
     - C++对名称的长度没有限制；
     - 如果用两个或者多个单词做名称，中间用下划线连接；或者从第二个单词开始将每个单词的首字母大写。

2. **整型**
- 基本整型：$char、short、int、long、long long$，其中每一种都有符号版本和无符号版本，总共有<font color=red>10种类型</font>可供选择。
  
   - $short、int、long、long long$多用这几种表示整数；
   
   - C++提供了一种灵活的标准，保证了最小长度：
   
     - <font color=red>short至少16位；</font>
     
     - int至少和short一样长；
     - long至少32位，且至少与int一样长；
   - long long至少64位，且至少和long一样长。
     
     > 位(bit)是计算机基本的内存单元，字节(byte)通常指8位的内存单元。
     
   - 运算符sizeof和头文件limits
   
     - sizeof：对类型名(如int)使用时，直接放入括号，如sizeof(int)；对变量名如(n_short)使用时，可以不用加括号，如sizeof n_short。
   
     - 头文件limits定义了符号常量，来表示类型的限制。
   
   - 初始化：初始化将赋值与变量声明合并在一起，<font color=blue>最好在声明的时候对变量进行初始化，不然会出现瞬间悬而未决的情况。</font>
   
   
	1. 无符号类型
	
	   - <font color=red>前面的4中类型都是有一种无符号类型的变体，不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。</font>当数值不为负时，如人数、粒数等等，可以使用无符号类型。
   
	   - 在创建时使用关键字unsigned来修改声明，<font color=red>unsigned本身是unsigned int的缩写。</font>

	2. 选择整型长度

      - int被设置为对目标计算机而言最为“自然”的长度，自然长度(nature size)指的是计算机处理起来效率最高的长度，<font color=red>如果没有非常有说服力的理由来选择其他类型，则应使用int；</font>
   
      - 如果变量没有负值，则一般使用无符号类型；
   
   - 如果变量可能表示的整数值大于16位整数的最大可能值，则使用long，即使系统上int为32位也可以这么做，这样程序移植到16位系统就不会出现兼容问题；如果存储的值大于20亿，可使用long long；
	
   - 如果short比int小，则使用short可以节省内存。通常，仅当有大型整型数组时，才有必要使用short。
   
   3. char类型：字符和小整数
   
      - char专门为存储字符（如数字和字母）而设计的；
   
      - 编程语言存储字母是通过使用字母的数值编码存储的，所以<font color=red>char是另一种整型;</font>

      - 它足够长，能表示计算机中的所有的基本符号：所有的字母、数字、标点符号等等；
   
      - char字面值

        - 对于常规字符（字母、标点和数字），<font color=blue>最简单的方法是将字符用单引号括起来，这种表示方法百事的是字符的数值编码，常用的是ASCII码；</font>
   
        - 转义字符。

	   - signed char和unsigned char
   
      - char在默认的情况下既不是没有符号的，也不是有符号的；

	   - 如果将char作为数值类型用作数值类型，那么差异就是重要的，unsigned char的表示范围通常为0~255，而signed char的表示范围是-128~127；
   
      - wcha_t（宽字符类型）

	     - 8位char可以表示基本字符集，wcha_t可以表示扩展字符集；
	
	     - cin和cout将输入和输出看成是char流，因此不适合处理wcha_t类型，但是有相似的工具：wcin和wcout，用以处理wchar_t类型。
	
	4. C++新增的类型：char16_t和char32_t
	
	   - char16_t是无符号的，16位；
	
	   - char32_t是无符号的，32位。
	
	5. bool类型：解释真假
	
	   - 真：true；假：false；
	
	   - true和false可以通过提升转换为1和0；任何0值可以被转化成false，非0值可以被转换成true。
## 1.2 const限定符

创建常量的通用格式：

<p style="color:blue;background-color:gray;text-align:center;">const type name = value;</p>
- 用来定义变量，它的值在程序的执行中不能被修改；
- <font color=red>const对象在定义的时候就要进行初始化；</font>
- 当const变量被初始化之后，其值被固定，编译器不允许再修改该常量的值
- const叫限定符，因为它限定了声明的含义。

## 1.3 **浮点数**

   - 浮点数能表示带小数部分的数字；
   - 浮点数提供的范围也更大，如果无法表示为long类型，则可以用浮点类型表示；
   - 计算机将浮点类型的数分成两部分来执行：
     - 一部分表示值；
     - 另一部分用于对其值的放大或者缩小；
     - <font color=red>缩放因子的作用是移动小数点的位置，术语浮点数因此得名。</font>

   - 浮点数的表示方法：
     - 常用的标准小数表示方法；
     - 表示浮点值的方法叫E表示法，如3.45E6，表示的是3.45*10^6。

   - 浮点类型
     - float、double、long double，通过表示的有效位数和允许的指数最小范围来描述的；
     - float至少32位；
     - double至少48位，且不少于float；
     - long double至少和double一样多；
     - 这三种类型的有效位数可以一样多，但是，通常float为32位，double为64位，long double为80、96或128位；
     - 这三种类型的指数范围至少是-37~37。

   - 优缺点

     - 优点：
       - 可以表示整数之间的值；
       - 由于有缩放因子，可以表示的数的范围更大；

     - <font color=red>缺点：浮点数运算速度慢，精度降低。</font>

## 1.4 **C++算术运算符**

   - C++提供了5种基本的算术计算：加、减、乘、除以及求模(%)，每种运算符都使用两个操作数。

   1. 运算符优先级和结合性
   2. 除法分支
      - <font color=blue>除法运算符(/)的行为取决于操作数的类型：两个操作数都是整数，执行整数除法，丢弃小数部分，结果是一个整数；操作数有一个是浮点数，小数部分保留，结果为浮点数。</font>
      - 运算符重载(operator overloading)：使用相同的符号进行多种操作。

   3. 求模运算符(%)：返回整数除法的余数。
   4. 类型转换：由于有11中整型和3种浮点型，因此在对不同的类型进行运算时，需要进行类型转换
      - 将一种算术类型的值赋给另一种算术类型的变量时；
      - 表达式中含有不同的类型时；
      - 将参数传递给函数时；
      - 强制类型装换：不会修改变量本身的值，而是创建一个新的、指定类型的值。

# 二、复合类型

## 2.1 数组



<img src=".\img\数组的创建.png" alt="数组的创建" style="zoom:80%;" />

<center>图2.1 数组的创建</center>
- 数组(array)是一种数据格式，能够存储多个相同类型的值，每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组中的各个元素。

- 要创建数组，可使用声明语句，<font color=blue>数组的声明应该指出下面三点：</font>

  ​	`声明格式：typeName arrayName[arraySize];`

  - 存储在每个元素中的值的类型：typeName；
  - 数组名：arrayName；
  - 数组中的元素个数：arraySize，必须是整型常数，不能是变量，但是可以用new来规避这种限制。

- 数组的很多用途都是基于这样一个事实：可以单独访问数组元素。方法是使用<font color=red>下标或者索引</font>来对元素进行编号，如图2所示。

- <font color=red>数组的初始化规则：</font>
  
  - <font color=blue>在定义的时候才能使用初始化，此后就不行了；</font>
  - 不能将一个数组赋给另一个数组，但是可以使用下标分别给数组中的元素进行赋值；
  - 如果只对数组的一部分进行初始化，那么未初始化的元素设置为0；
  - 如果初始化数组时方括号内([])为空，编译器会计算元素的个数。



## 2.2 字符串

**字符串是存储在内存的<font color=blue>连续字节</font>中的一系列字符。**

- C++中有两种处理字符串的方法：<font color=red>C-风格字符串和基于string类库的方法；</font>下面主要介绍C-风格字符串的方法。
- 存储在连续字节中的一系列字符意味着将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。
- C-风格字符串有一个特殊的性质：<font color=red>以空字符(null character)结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。</font>

- 对字符数组初始化

  - 用大括号进行赋值：

    - `char cat[4]={'f','a','t','\0'};`
    - 必须在后面添加'\0'，否者编译器不会停止；

  - 可以用<font color=blue>双引号</font>将字符串<font color=red>（使用单引号的是字符常量）</font>括起来进行赋值，这种字符串称为字符串常量或者字符串字面值：

    - `char bird[11] = "Mr. Cheeps";`

    - 用引号括起来的字符串隐式包含括结尾的空字符；

    - <font color=red>注意在初始化字符串数组大小的时候，要将空字符算进去。</font>

      ![初始化字符串](.\img\初始化字符串.png)

    <center>图2.2 将数组初始化为字符串</center>

1. 拼接字符串常量
   - 任何两个由<font color=blue>空白（空格、制表符和换行符）</font>分隔的字符串常量都将自动拼接成一个；
   - <font color=red>注意：</font>拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面；第一个字符串中的\0字符会被第二个字符串的第一个字符取代。 

2. 在数组中使用字符串

   - 将字符串存储到数组中，最常用的方法有两种：
     - 将数组初始化为字符串常量，将用双引号引起来的字符串赋值给数组；
     - 将键盘或文件输入读入到数组中，用cin将一个输入字符串放到数组中。

3. 字符串输入

   - 由于不能通过键盘键入空字符，所以用cin读入字符串时需要用别的方式来确定字符串的结尾；<font color=red>cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这就意味着cin在读取时只能读取一个单词；</font>
   - 还有一个问题就是，输入字符串比目标数组长。
   - <font color=blue>对于上面的问题，需要利用cin的高级功能才行；</font>
   - cin读取输入会跳过空白（空格、执行符和制表符）。

4. 每次读取一行字符串输入

   - 对于上面的问题，虽然istream中的类（如cin）提供了一些面向行的类函数：getline()和get()，这两个函数都会读取一行的值，知道遇到换行符；<font color=blue>但是getline()会丢弃换行符，get()会将换行符保留在输入序列中。</font>

   - getline()函数

     - getline()读取整行，使用通过回车键输入的换行符来确定输入结尾，会丢弃换行符（将换行符替换成\0）；

       调用方法：`cin.getline(name,20)`, 函数有两个参数，<font color=purple>第一个是用来存储的数组名称，</font>第二个是要读取的字符数（有一个需要用来存放\0）；
     
   - get()函数
     
     ​	调用方式`cin.get(name,number);`
     
     - get()函数不再读取和丢弃换行符，而是<font color=red>将换行符留在输入序列中，第二次调用的时候get()最先遇到的还是换行符，如果不借助帮助就不能跳过去；</font>
     - <font color=blue>幸运的是，可以使用不带参数的get()函数来处理；另外一种使用get()的方式是将两个函数拼接：`cin.get(name,20).get()`, 后面的get()处理换行符。</font>

5. 混合输入字符串和数字

   - 要注意读取过程中的换行符，可以用`cin.get()`来处理。



## 2.3 string类简介

**可以使用string类型的变量（对象）而不是字符数组来存储字符串。**

- 要使用string类，必须要包含头文件string，并且string类位于命名空间std中，因此必须提供using编译指令（`using namespace std`）

- string对象和字符数组之间的主要区别：<font color=blue>可以将string对象声明为==简单的变量==，而不是数组，</font><font color=red>类设计让程序能够自动处理string的大小；</font>
- <font color=blue>从理论上说，可以讲char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。</font>

1. 赋值、拼接和附加
   - 不能将一个数组赋值给另一个数组，但是一个string对象可以赋值给另一个string对象；
   - string类简化了字符串合并操作，可以使用运算符“+”将两个string对象合并起来

2. string的其他操作

   ​	使用头文件cstring：

   - strcpy()将字符串复制到字符数组中；
   - strcat()将字符串附加到字符数组末尾；
   - 类方法str.size()可以返回字符串包含的字符数。

3. string类I/O

   - 可以使用cin和>>来将输入存储到string数组，使用cout和<<来显示string对象

   - <p style="color=blue;background-color:red;text-align:center;">此处有问题，看书p87。</p>

## 2.4 结构简介

**结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据。**

- 结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型之后便可以创建这种类型的变量，因此创建结构包括两步：

  - 首先，定义结构描述——它描述并标记了能够存储在结构中的各种数据类型；

  - 然后，按照描述创建结构变量。

    <img src=".\img\结构描述的组成部分.png" style="zoom:80%;" />

    <center>图2.3 结构描述的组成部分</center>

  - <font color=red>在C++中，结构标记的用法与基本类型名相同，与C中的结构使用相比，C++中允许在声明结构变量时省略关键字struct，这种变化强调的是，结构声明定义了一种新类型；</font>

  - 可以中成员运算符(.)来访问各个成员。
1.  <font color=blue>结构声明的位置很重要：</font>
    - 可以将声明放在main()函数中，紧跟在开始括号后面，称为内部声明；
    - 可以将声明放到main()函数的前面，称为外部声明；
    - <font color=blue>两者的差别不大，只是内部声明只能被所属的函数调用，外部声明可以被其后面的函数调用。</font>

2. 结构初始化
   - C++11支持将列表初始化用于结构，且等号（=）是可选的
   - 如大括号内不包含值，则每个成员都被设置为0。
   - `inflatable duck={"Paphne", 0.12, 9.98};或者infltable duck {};`
  - 上面的等号(=)是可选的。

3. 结构支持将string类作为成员
4. 其他结构属性
   - 可以将结构作为参数传递给函数，也可以让函数返回一个结构；
   - 可以用赋值运算符（=）将结构赋给另一个<font color=red>同类型</font>的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，这种赋值方式成为成员赋值(memberwise assignment)。

5. 结构数组
   - `inflatable gifts[100];`
   - gifts将是一个inflatable数组，其中每个元素（如gifts[0]）都是inflatable对象，可以和成员运算符一起使用。

6. 结构中的位字段



## 2.5 共用体

- 共用体(union)是一种数据格式，能存储不同的数据类型，但是只能同时存储其中的一种类型，也就是说，<font color=blue>结构可以同时存储int、long、和double，但是共用体<font color=red>一次操作</font>只能存储一种类型int或long或double；</font>
- 公用体的用途之一是，当数据项使用两种或者多种格式（但不会同时使用）时，可以节省空间，如一个管理商品的目录，一些商品的id是数字，一些商品的id是字符串，这种情况下就可以使用共用体；
- 共用体常用于节省内存，操作系统数据结构或硬件数据结构。

## 2.6 枚举

- enum工具提供了另一种<font color=red>创建符号常量的方法，这种方式可以代替const；</font>
- 使用enum的句法与使用结构相似：
  - `enum spectrum {red, orange, yellow, green};`
    - 让spectrum成为新类型的名称；spectrum称为枚举，就像struct变量被称为结构一样；
    - 将red, orange,yellow,green等作为符号常量，他们对应整数值为0~3，这些常量叫做枚举量。

1. 设置枚举量的值
   - 可以使用运算符显示得赋值。
     - `enum bigstep{first, second=100,third};`
     - <font color=red>first默认为0，没有初始化的比前面的大1，所以third为101。</font>
2. 枚举的取值范围
   - 定义`enum bits{one=1, two=2, four=4, eight=8}; bits myglag;`
   - `myflag=bits(6)`是合法的，其中6不是枚举量，但是它位于枚举定义的范围之内；
   - 取值范围定义：
     - 首先，找出上限，需要知道枚举量的最大值，找到大于这个最大值的最小的2的幂，减去1，如bigstep中最大为101，所以大于101的最小的2的幂是128，减去1等于127；
     - 找到下限，需要知道枚举量的最小值，如果它不小于0，那取值范围下限为0；否则，采用与上限相同的方式，但是要加上负号，如最小为-6，那么下限就是-7。



## 2.7 指针

指针是与前面的存储不一样的策略，<font color=blue>指针是一个变量，其存储的是值得地址，而不是值本身。</font>对常规的变量可以用取地址符号(&)来获得变量的地址。

- 指针用于存储值的地址，因此，<font color=red>指针名表示的是地址；</font>

- <font color=blue>*运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，</font>将其引用到指针，可以得到该地址处存储的值；

  <img src=".\img\指针的值.png" alt="指针的值" style="zoom:80%;" />

  <center>图2.4 指针的值</center>

1. 声明和初始化指针

   - 计算机需要跟踪指针指向的值得类型，例如，char的地址和double的地址看上去是没什么区别的，但是他们存储值时使用的内部格式不同，所以<font color=red>指针必须指定指针指向的数据的类型；</font>

   - 例如`int * p_updates;`

     - `* p_updates`的类型为int，由于*运算符被用于指针，因此p_updates变量本身必须是指针；

     - 我们说p_updates指向int类型，也说p_updates的类型是指向int的指针，或int*；

     - 也可以这样说，p_updates是指针（地址），而*p_updates是int，而不是指针。

       <img src=".\img\指针存储地址.png" alt="指针存储地址" style="zoom: 80%;" />

       <center>图2.5 指针存储地址</center>
- <font color=blue>btw  \*运算符两边的空格是可选的，C++中一般使用这种格式：`int* ptr`，这里强调的是，int*是一种类型——指向指针的类型；</font>
       - 对每一个指针变量名都需要一个\*符号，`int* p1, p2; `声明的是创建一个指针p1和一个int变量的p2，int* 是一个复合类型。
   
2. 指针的危险

   - <font color=red>在C++中创建指针时，计算机将分配用来存储内存的地址，而不会分配用来存储指针所指向的数据的内存；</font>

   - <p style="color:blue;background-color:red;text-align:center;">一定要在对指针应用解除引用运算符(*)之前，将指针初始化为一个确定的、适当的地址！</p>

3. 指针和数字

   - 虽然计算机通常把地址当做整数处理，但是指针不是整型；
   - 指针和整数是截然不同的概念，整数是可以执行加、减等运算的，而指针描述的是位置，将两个位置进行相乘是没任何意义的，因此<font color=red>不能简单地将整数赋值给指针。</font>

4. 使用new来分配内存

   <font color=red>为一个数据对象获得并指定内存的通用格式：</font>

   <p style="color:blue;background-color:gray;text-align:center;">typeName* pointer_name = new typeName;</p>
   - 变量是在编译时分配的有名称的内存，而<font color=red>指针只是为可以通过名称直接访问的内存提供了一个别名，指针的用武之地在于，在运行阶段分配未命名的内存及存储值。</font>
   - C语言中使用malloc()函数来分配内存，C++中也可以，但是C++中有更好的——new运算符；
   - `int* pn = new int;`
     - new int 告述程序，需要适合存储int的内存，<font color=blue>new运算符根据类型来确定需要多少字节的内存，然后它找到这样的内存，并返回其地址，然后将地址赋值给pn；</font>

   - 原先的方法：`int higgens; int* pt = &higgens;`
     - 这种方式可以通过名称higgens来访问该int；
     - 但是第一种情况则只能通过该指针进行访问，这就出现一个问题：pn指向的没有名称，怎么称呼它哪？我们称它为数据对象（并不是OOP中的对象，指的是“东西”）。

   - <font color=red>需要指出，new分配的内存块通常与常规变量声明的内存块不同，<font color=blue>变量的值被存储在称为栈(stack)的内存区域中，</font>而new从被称为堆(heap)或自由存储区(free store)的内存区域分配内存。</font>

5. 使用delete来释放内存

   - 需要内存时，可以使用new来请求；在使用完内存后可以使用delete来释放内存；
     - `int * ps = new int;...;delete ps;`, <font color=blue>使用delete将会释放ps指向的内存，但不会删除指针ps本身</font>;
     - <font color=red>一定要配套使用new 和delete，否则将发生内存泄露(memory leak，就是说被分配的内存再也无法使用)。</font>
     - ==使用new和delete时，应遵循以下规则：==
       - 不要使用delete来释放不是new分配的内存；
       - 不要使用delete释放同一个内存块两次；
       - 如果使用new [] 为数组分配内存，则应使用delete [ ]来释放；
       - 如果使用new为一个实体分配内存，则应使用delete来释放；
       - 对空指针应用delete是安全的。  

6. 使用new来创建动态数组

   <font color=red>为数组分配内存的通用格式：</font>

   <p style="color:blue;background-color:gray;text-align:center;">typeName* pointer_name = new typeName [num_elements];</p>
- <font color=blue>对于管理小型数据对象来说，声明简单的变量比使用new和指针更简单；但是对于大型数据（数组、字符串和结构），应使用new。</font>
   - <font color=red>静态联编(static binding)，</font>在编译时给数组分配内存；<font color=red>动态联编(dynamic binding)</font>，数组在程序运行时创建，使用new，在运行阶段需要数组，则创建它，不需要，则不创建。
   
- 动态数组的两个基本问题：<font color=blue>如何使用C++的new运算符创建数组</font>以及<font color=blue>如何使用指针访问数组元素。</font>
     - 使用new运算符创建数组
       - <font color=blue>只需要将数组的元素类型和元素数目告诉new即可，必须在类型名后加上方括号，其中包含元素数目：</font>`int* psome = new int [10];...;delete [] psome;`, 方括号告诉程序，应该释放整个数组，而不仅仅是指针指向的元素。
     - 使用指针访问数组元素
       - `int* psome = new int [10];`语句创建了指针psome，它指向包含10个int值的内存块的第一个值，因此可以将它看成指向该元素的一根手指，将该手指沿正确的方向移动4个字节，手指将指向下一个元素。<font color=red>所以，new语句提供了识别内存块中每个元素所需的全部信息。</font>
       - 在C++中，要使用new创建的数组：<font color=blue>只需要把指针当成数组名使用即可。也就是说，对第一个元素，用psome[0]，第二个元素，用psome[1]，以此类推。</font>

7. **指针、数组和指针算术**

   <font color=red>指针和数组等价的原因在于指针算术(pointer arthmetic)和C++内部处理数组的方式。</font>

   - C++允许将指针和整数想加，加1的结果等于原来的地址加上指向的对象占用的总字节数；
   - 还可以将一个指针减去另一个指针，获得两个指针的差，仅当两个指针指向同一个数组时才有意义，这将得到两个元素的间隔。



## 2.8 类型组合

前面介绍了数组、结构和指针，可以各种方式组合它们。



## 2.9 数组的替代品

模板类vector和array是数组的替代品。

1. **模板类vector**

   <p style="color:blue;background-color:gray;text-align:center;">vector &lt;typeName&gt; vt(n_elem); </p>
==其中参数n_elem可以是整型常量，也可以是整型变量。==
   
- 模版类vector类似于string类，也是一种动态数组；
   - <font color=blue>实际上，vector类是使用new和delete来管理内存，但这种工作是自动完成的，可以在运行阶段设置vector对象的长度，可在末尾添加新数据，也可以在中间插入新数据；</font>
   - <font color=red>一点使用知识：</font>
     - 要使用vector类，必须包含vector头文件
     - 需要用using namespace std编译指令；
     - 模板使用不同的语法来指出它存储的数据类型；
     - vector使用不同的语法来指定元素数。
   
2. **模板类array**

   <p style="color:blue;background-color:gray;text-align:center;">array &lt;typeName,n_elem&gt; arr;</p>
==参数n_elem只能是整型常量，不能是变量。==
   
- vector类的功能比数组强大，但是付出的代价是<font color=red>效率稍低</font>;
   - array类也位于名称空间std中；
   - <font color=blue>与数组一样，array对象的长度也是固定的，也是使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但是更方便，更安全；</font>
   - 使用时需要包含头文件array；
   
3. ****

   **比较数组、vector类和array类的**

   - 3种方式都可以使用标准的数组表示法来访问各个元素；
   - 由地址可知，array对象和数组存储在内存区域（栈）中，而vector对象存储在另一个区域（自由存储区或堆）中；
   - 可以将一个array赋值给另一个array，但是对于数组，必须逐元素复制数据。

<p style="color:blue;background-color:red;text-align:center;">Summary</p>
- 数组、结构和指针是C++的三种复合类型，数组可以在一个数据对象中存储多个同类型的值，通过索引或下标，可以访问数组的各个元素；
- 结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符(.)来访问其中的成员；
  - 使用结构的第一步是创建模板，它定义了结构存储了哪些成员，模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。

- 共用体可以存储一个值，但是这个值可以是不同的类型；
- 指针是被设计用来存储地址的变量，我们说，指针指向它存储的地址。指针声明指出了指针指向的对象的数据类型，对指针应用解除引用运算符，可以得到指针的位置中的值。
- 字符串是以空字符结尾的一系列字符，字符串可以用引号括起来的字符串常量来表示，其中隐式包含了结尾的空字符。

# 三、循环和关系式

## 3.1 for循环

- 完成需要重复执行的任务。

1. **for循环的组成部分**

   - for循环的组成部分完成下面的步骤：
     1. 设置初始值；
     2. 执行测试，看看循环是否应当继续进行；
     3. 执行循环操作；
     4. 更新用于测试的值。

   <img src="F:\学习\编程语言相关\C plus plus\img\for循环.png" alt="for循环" style="zoom:80%;" />

   <center>图3.1 for 循环</center>
   - `for (initialization; test-expression; update-expression)`

     `body`（循环体）；

     - C++语法将整个for循环看作一条语句——虽然循环体可以包含一条或多条语句；
     - <font color=blue>循环只执行一次初始化，通常程序使用该表达式将变量设置为起始值，然后用该变量计算循环周期；</font>
     - test-expression决定循环体是否被执行，通常这个表达式是<font color=red>关系表达式</font>；
     - for循环是<font color=red>入口条件(entry-condition)循环</font>，在每轮循环之前都要计算测试表达式的值，当测试结果为false时将不会执行循环体;
     - update-expression（更新表达式）在每轮循环结束时执行，此时循环体已经执行完毕；<font color=red>通常它用来对跟踪循环轮次的变量的值进行==增减==。</font>
     - <font color=red>C++中==通常在for和括号之间加上一个空格==，而省略函数名与括号之间的空格。</font>

   - 表达式和语句
     
   - C++中每一个表达式都有值，<font color=blue>C++将赋值表达式的值定义为左侧成员的值</font>，赋值运算符是从左到右结合的；
     
   - 非表达式和语句
     
   - 任何表达式加上分号都可以成为语句，反之不成立。
     
   - <font color=red>与C不同的是</font>
     
     - C++中允许在for循环的初始化部分声明变量。

2. **修改步长**
- 修改update-expression表达式来修改补偿，不是只能用“++”或“--”。
  
3. **递增运算符(++)和递减运算符(--)**
   
   - 递增运算符(++)：
     - 将循环计数加1；
     - 后缀(postfix) a++, 表示使用a的当前值计算表达式，然后再将a加1；
     - 前缀(prefix) ++b, 表示先将b的值加1，再使用新的值来计算表达式。
   - 递减运算符(--)：
     - 将循环计数减1；
  - 前缀和后缀的使用同(++)。

4. **递增/递减运算符和指针**
   - 将递增运算符用于指针时，<font color=blue>将把指针的值增加其指向的数据类型占用的字节数，</font>这种规则适用于对指针的递增和递减；
   - 也可以结合递增/递减运算符和*运算符来修改指针指向的值，将++和\*同时作用于指针，但是就会出现一个问题：<font color=red>将什么解除引用，将什么递增</font>，这个取决于运算符的位置和优先级；
     - 前缀递增、前缀递减和解除引用运算符的优先级相同，以从右往左的方式结合；后缀递增和后缀递减的优先级相同，但是比前缀运算符的优先级高，这两个运算符以从左往右的方式进行结合。
     - 前缀运算符的<font color=blue>从右到左</font>结合规则意味着<font color=red>\*++pt的含义</font>如下：
       - 先将++应用于pt（因为++位于\*的右边）；
       - 然后将\*应用于被递增后的pt。

5. **组合赋值运算符**

   | 操作符 | 作用（L为左操作数，R为右操作数） |
   | :----: | :------------------------------: |
   |   +=   |            将L+R赋给L            |
   |   -+   |            将L-R赋给L            |
   |  \*=   |           将L\*R赋给L            |
   |   /=   |            将L/R赋给L            |
   |   %=   |            将L%R赋给L            |

6. **复合语句（语句块）**
   - 用两个花括号"{}"来构造一条复合语句（代码块），代码块由<font color=red>一对花括号和他们包含的语句组成</font>，被视为一条语句;
   - 有趣的特性：如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在，执行完该语句后，变量将释放，表明此变量仅在语句块中才是可用的。

7. **逗号运算符**

   - 逗号运算符允许将两个表达式放到C++句法只允许放一个表达式的地方；
     - 例如有一个循环每轮都将一个变量加1，将另一个变量减1，这时可用：`++j,++i`。

8. **关系表达式**

   | 操作符 |    含义    |
   | :----: | :--------: |
   |   <    |    小于    |
   |   <=   |  小于等于  |
   |   ==   |    等于    |
   |   >    |    大于    |
   |   >=   | 大于或等于 |
   |   !=   |   不等于   |

## 3.2 while循环

- while循环是<font color=blue>没有</font><font color=red>初始化和更新部分</font>的for循环，它只有测试条件和循环体；

  `while (test-condition)`

  ​			`body`

  - 首先计算测试条件test-condition表达式，如果该表达式为ture，则执行循环体中的语句，直到test-condition为false；
  - while循环也是一种入口条件循环，如果条件一开始就是false，那么程序就不会执行循环体。

- <font color=red>for与while</font>

  - 在C++中for与while的本质是相同的：
    - for循环需要3个表达式，不过它们都可以是空表达式，<font color=red>只有两个分号是必需的</font>

  - 它们之间的3个差别：
    - 在for循环中省略了测试条件时，将认为条件为true；
    - 其次，在for循环中可以使用一个初始化语句声明一个局部变量，但是在while循环中不能这样做；
    - 如果循环中包含continue语句，情况稍有不同。

- 设计循环时的指导准则：

  - 指定循环终止条件；
  - 在首次测试之前初始化条件；
  - 在条件再次测试前更新条件。

  <font color=blue>for 循环的一个优点：</font>其结构提供了可以可实现上述3条指导原则的地方，因此有助于程序员记住这3点。

## 3.3 do while 循环

- do while 循环不同于前面两种入口条件循环，它是<font color=red>出口条件循环</font>。

  - <font color=red>循环将首先执行循环体，然后再判定测试表达式，决定是否继续执行循环，</font>这样的循环至少执行一次；

  - do while 循环语法：

    ```c++
    do
      body
    while (test-condition);
    ```

    

  <img src="F:\学习\编程语言相关\C plus plus\img\do while 循环.png" alt="do while 循环" style="zoom:80%;" />

  <center>图3.2 do while 循环</center>
- <font color=red>通常，入口条件循环比出口条件循环好，因为入口条件再循环开始之前对条件进行检查。</font>

## 3.4 基于范围的for循环

- C++11 新增加的一种循环，这种循环简化了一种常见的循环任务：<font color=blue>对数组（或容器类，如vector和array）的每个元素执行相同的操作：</font>

  ```c++
  double prices[5]={4.99,10.99,6.87,7.99,8.49};
  for (double x:)
  	cout << x << endl;
  ```

  - <font color=blue>对上面的程序：x最初表示数组prices的第一个元素，显示第一个元素之后，不断执行循环，而x依次表示执行数组中的其它元素；</font>上述代码依次显示全部的5个元素，每个元素占据一行。

  - <font color=red>上面的方法不能修改数组的内容，需要用下面的方法：</font>

  ```c++
  for (double &x : prices)
  	x = x * 0.80;
  ```

  - 符号&表明x是一个引用变量，这个可以让后面的代码修改数组的内容。

## 3.5 循环和文本输入

- 循环完成的一项最常见、最重要的任务：<font color=blue>逐字符地读取来自文件或键盘的文本；</font>
- C++中cin对象支持3种不同模式的单字符输入，其用户接口各不相同；

1. **使用原始的cin进行输入**
   
   - 要读取来自键盘的文本输入，就必须要知道何时停止读取，一种方法是选择某个特殊字符——有时被称为<font color=red>哨兵字符(sectinel character)</font>，将其作为停止标记；
   - cin读取char字符将忽略空白（回车、空格和制表符），<font color=blue>所以在回显的时候就不会显示空白</font>；
   - 发送给cin的输入被缓冲，这就意味着只有在用户按下回车键后，输入的内容才会被发送给程序。
2. **使用cin.get(char)进行补救**
   - 通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符，<font color=red>cin所属的iostream类中的成员函数cin.get(char)读取输入中的下一个字符（即使他是个空白）</font>，并将其赋值给变量char。
   - 由于cin.get()可以读取空白，那么就可以解决上面的不能回显空白的问题
3. **cin.get的版本**
   - cin.get()的第一个版本，<font color=red>接受两个参数：</font>数组名（字符串（char*类型）的地址）和Arsize（int类型的整数）；<font color=red>数组名是第一个元素的地址，因此字符数组名的类型为char\*；</font>
   - cin.get()的第二个版本，<font color=red>接受一个参数：</font>一个char参数。

4. **文件尾条件**

   - 在用特殊符号本就是输入字符的一部分的时候，用特殊符号来检测输入结束的方法就不适用，则可以使用检测文件尾(EOF)的方法；

     - C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序；
     - 操作系统允许通过键盘来模拟文件尾条件：
       - Unix中，可以在行首按下Ctrl+D;
       - Windows中，在命令提示符模式下，<font color=red>在任意位置按Ctrl+Z和Enter；</font>

     - 检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eofbit是否被设置，如果检测到EOF
       - cin.eof()将返回true，否则返回false；
       - cin.fail()将返回true，否则返回false；

     - <font color=red>注意：</font>eof()和fail()方法报告最近读取的结果，也就是说它们在事后报告，<font color=red>所以应将cin.eof()和cin.fail()测试放在读取之后。</font>

   - 常见的字符串输入做法：

     ```C++
     cin.get(ch);
     while (cin.fail() == false)
     {
     	...
     	cin.get(ch);
     }
     
     也可以写成：
     while (cin.get(ch))
     {
     	...
     }
     将三条指导原则（确定结束条件、对条件进行初始化和更新条件）全部放在循环测试条件中。
     ```

   - cin.get(ch)与cin.get()的区别

     |            属性            |             cin.get(ch)             |    ch=cin.get()    |
     | :------------------------: | :---------------------------------: | :----------------: |
     |     传递输入字符的方式     |             赋给参数ch              | 将函数返回值赋给ch |
     | 用于字符输入时函数的返回值 | istream对象（执行bool转换后为true） | int类型的字符编码  |
     |   到达EOF时函数的返回值    | istream对象（执行bool转换后为true） |        EOF         |

     - <font color=red>使用字符参数的版本更适合对象方式，</font>因为其返回值是istream对象，这意味着可以将它们拼接起来：

       `cin.get(ch1).get.(ch2);`将下一个字符读取到ch1中，并将接下来的一个字符读入到ch2中。

## 5.6 嵌套循环和二维数组

- 二维数组

  - 二维数组就像一个表格，既有行也有列；

  - C++没有提供二维数组的类型，但用户可以创建每个元素本身都是数组的数组：

    - 例如要存储5个城市在4年间的最高温度，可以这样声明数组：`int maxtemps[4][5];`

    - 这意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组；

      <img src="F:\学习\编程语言相关\C plus plus\img\数组组成的数组.png" alt="数组组成的数组" style="zoom: 50%;" />

      <center>图3.3 由数组组成的数组</center>
      - 表达式maxtemps[0]表示的是maxtemps数组的第一个元素，maxtemps\[0][0]表示maxtemps[0]的第一个元素。
  
  1. **初始化二维数组**
  
     - 创建二维数组时可以初始化其所有元素，这是建立在一维数组初始化技术之上的：<font color=red>提供由逗号分隔的用花括号括起来的列表：</font>
  
       ```c++
       int maxtemps[4][5] = 
       {
       	{96,100,87,101,105},//value for maxtemps[0]
       	{97,101,88,102,106},
       	{99,102,89,103,107},
       	{99,103,90,107,108},//value for maxtemps[3]
       };
       ```
  
  2. **使用二维数组**
     
     - 使用嵌套循环可以读取二维数组中的值。

# 四、分支语句与逻辑运算符

## 4.1 if 语句

- 当C++程序必须决定是否执行某个操作时，通常用if语句来实现选择，if有两种格式：<font cilor=blue>if 和if else;</font>

1. **if 语句**

   - if语句的语法与while相似：

     ```c++
     if (test-condition)
     	statement
     ```

     - 如果test-condition为true，则程序将执行statement，这既可以是一条语句也可以是一个语句块；如果为false，将跳过statement；和循环条件一样，if测试条件也将被将至转换为bool类型；
     - 通常情况下，测试条件都是关系表达式；

   <img src=".\img\if语句结构.png" alt="if语句结构" style="zoom:67%;" />

   <center>图4.1 if语句结构</center>

2. **if else 语句**

   - if语句让程序决定是否执行特定的语句或语句块，<font color=red>而if else 则让程序决定执行两条语句或语句块中的哪一条；</font>

   - if else 语句的通用格式为：

     ```C++
     if (test-condition)
     	statement1
     else if
     	statement2
     ```

     - 如果测试条件为true，则程序执行statement1，跳过statement2；测试条件为false，则程序跳过statement1，执行statement2；statement是一条语句或一个语句块；

   <img src=".\img\if else语句的结构.png" alt="if else语句的结构" style="zoom:67%;" />

   <center>图4.2 if else 语句的结构</center>
3. **if else if else 结构**
   
   - 可以提供两个以上的选择，可以进行多个 else if 的嵌套；
   
     ```C++
        if (test-condition1)
        	statement1
        else if (test-condition2)
        	statement2
        else
        	statement3
     ```

## 4.2 逻辑表达式

- C++有3种逻辑运算符；

1. **逻辑OR运算符: ||**

   - 当<font color=red>两个条件中至少有一个条件为true</font>时，表达式为true，否则为false；
   - ||的优先级比关系运算符低；
   - C++规定，||运算符是个顺序点(sequence point)，就是说先修改左侧的值，再对右侧的值进行判定；

   |               | expr \|\| expr2 的值 |               |
   | ------------- | :------------------- | ------------- |
   |               | exp1 == true         | exp1 == false |
   | exp2 == true  | true                 | true          |
   | exp2 == false | true                 | false         |

2. **逻辑AND 运算符：&&**

   - &&也是将两个表达式组合 成一个表达式，仅当原来的表达式都为true时，得到的表达式的值才为true；
   - &&的优先级比关系运算符低；
   - &&也是顺序点，先判定左边的值，如果左侧的值为false，则整个逻辑表达式的必定为false，在这种情况下就不会对右侧的值在进行判定。

   |               | expr && expr2 的值 |               |
   | ------------- | :----------------- | ------------- |
   |               | exp1 == true       | exp1 == false |
   | exp2 == true  | true               | false         |
   | exp2 == false | false              | false         |

3. **用&&来设置取值范围**
   
- &&运算符还允许建立一系列if else if else 语句，<font color=red>其中每种选择都对应于一个特定的取值范围。</font>
  
4. **逻辑NOT 运算符：！**
   - ！运算符将它后面的表达式的真值取反；
   - expr 为true，那么!expr为false；expr 为false，那么!expr为true；
   - !运算符的优先级<font color=red>高于</font>所有的关系运算符和算数运算符，因此对表达式求反，必须用括号将其括起来；

- 逻辑运算符可以使用对应的and、or、not来进行表示。

## 4.3 字符函数库cctype

- 可以确定字符是否为大写字母、数字、标点符号等工作；
- 包含在头文件cctype中；

| 函数名称   | 返回值                                                       |
| ---------- | ------------------------------------------------------------ |
| isalnum()  | 如果参数是字母数字，即字母或数字，该函数返回true；           |
| isalpha()  | 如果参数是字母，该函数返回true；                             |
| iscntrl()  | 如果参数是控制字符，该函数返回true                           |
| isdigit()  | 如果参数是数字(0~9)，该函数返回true                          |
| isgraph()  | 如果參数是除空格之外的打印字符，该函数返回true；             |
| islower()  | 如果参数是小写字母，该函数返回true；                         |
| isprint()  | 如果参数是打印字符(包括空格)，该函数返回true；               |
| ispunct()  | 如果参数是标点符号，该函数返回true；                         |
| isspace()  | 如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true； |
| isupper()  | 如果参数是大写字母，该函数返回true；                         |
| isxdigit() | 如果参数是十六进制数字，即0\~9、a\~f、A\~F​该函数返回true;    |
| tolower()  | 如果参数是大写字符，则返回其小写，否则返回该参数；<font color=red>返回的是ASCII码，显示字符需要进行char类型转换；</font> |
| toupper()  | 如里参数是小写字符，则返回其大写，否则返回该参数。           |

## 4.4 ?:运算符，条件运算符

- C++中用来替代if else 语句的运算符，?:被称为<font color=blue>条件运算符</font>，<font color=red>它是C++中唯一一个需要3个操作数的运算符；</font>
- 运算符的通用格式：`expression1 ? expression2 : expression3`
  - 如果expression1为true，则整个表达式的值为expression2的值；否则，整个表达式的值为expression3的值。

- 条件运算符格式简洁、语法奇特，其中一个受欢迎的技巧是，将条件表达式嵌套在另一个表达式中；
- 从可读性来说，条件运算符最适合简单关系和简单表达式的值，当代码变得复杂时，用if else 来表达更为清晰。

## 4.5 switch语句

- C++的switch语句可以从大型列表中进行选择，switch语句的通用格式：

  ```C++
  switch (integer-expression)
  {
      case label1: statement(s)
      case label1: statement(s)
             ... 
      default: statement(s)
  }
  ```

- C++的switch语句就像指路牌，告诉计算机接下来执行哪行代码；
  - 执行到switch语句时，程序将跳到使用integer-expression的值标记的那一行，例如，integer-expression的值为2，程序将跳到标记到label2的那一行；
  - 如果没有integer-expression的值标记的标签，那么将会跳到default的那一行；
  - default标签是可选的，如果被省略，而又没有匹配的标签，则程序将跳到switch后面的语句处执行。
  - <font color=red>最常见的标签是int或char常量（如1或'q'），也可以是枚举量。</font>

<img src="F:\学习\编程语言相关\Python\img\switch语句的结构.png" alt="switch语句的结构" style="zoom: 80%;" />

<center>图4.3 switch语句的结构</center>
1. **将枚举量用作标签**
   - 当switch语句将int值和枚举量标签进行比较时，将枚举量提升为int，在while循环测试条件中，也会将枚举量提升为int类型。
2. **switch和if else**
   - switch语句和if else 语句都允许程序从选项中选择，相比之下if else更通用；
   - if else可以处理取值范围，switch语法中的每一个case标签都必须是一个单独的值，这个值必须是整数（包括char），因此switch无法处理浮点测试，且case标签也必须是常量；
   - 选项涉及取值范围、浮点测试或两个变量的比较，应使用if else；
   - <font color=blue>如果选项都是用整数常量标识的，且选项超过两个，则就代码长度和执行速度而言，switch语句的效率更高。</font>

## 4.6 break和continue语句

- break和continue语句都能使程序能够跳过部分代码；

  - 可以在switch语句或任何循环中使用break语句，<font color=red>使程序跳到switch或循环后面的语句处执行；</font>

  - continue语句用于循环中，<font color=red>让程序跳过循环体中余下的代码，并开始新一轮循环。</font>

    <img src=".\img\break和continue语句的结构.png" alt="break和continue语句的结构" style="zoom: 67%;" />

    <center>图4.4 break和continue语句的结构</center>

- 在for循环中，continue语句使程序<font color=red>直接跳到更新表达式处，然后跳到测试表达式处</font>；
- 对于while循环来说，continue将使程序<font color=red>直接跳到测试表达式处，因此while循环体中位于continue之后的表达式都将被跳过。</font>

- C++也有`goto`语句，用来跳转到指定的标签，但是，大多数情况下，使用goto语句不好，应该使用<font color=blue>结构化控制语句</font>(如if else、switch、continue等)来控制程序的流程。

## 4.7 读取数字的循环

<p style="color:red;background-color:gray">将在后面进行讨论！</p>
## 4.8 简单文件输入输出

<p style="color:red;background-color:gray">将在后面进行讨论！</p>
# 五、函数

- 要使用C++函数，必须完成如下的工作：
  - <font color=red>提供函数定义；</font>
  - <font color=red>提供函数原型；</font>
  - <font color=red>调用函数。</font>

- <font color=blue>库函数是已经定义好和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需要正确地调用这种函数即可。</font>
- 要创建自己的函数，必须要完成上面的三步。

## 5.1 函数的基本知识

- ==函数的特性==
  - 有函数头和函数体；
  - 接受参数；
  - 返回值；
  - 需要一个原型。

1. 定义函数

   - 函数可以分成两类：<font color=red>没有返回值的函数</font>和<font color=red>有返回值的函数</font>；

     - 没有返回值得函数：

       - 通常被称为void函数，其通用格式如下：

         ```C++
         void functionName(paramrterList)
         {
             statement(s);
             return;//optional
         }
         ```

     - 有返回值的函数：

       - 有返回值得函数将生成一个值，并将它返回给调用函数：其通用格式如下：

         ```C++
       void functionName(paramrterList)
         {
             statement(s);
             return value;
         }
         ```
     
       - ==必须使用返回语句==，以便将值返回给调用函数。C++对返回值的限制，<font color=red>不能是数组</font>，可以是整数、浮点数、指针，甚至可以是结构和对象。
     
       - ==通常main()函数也是要有返回值的：==
       
         - 可以将计算机操作系统看作调用程序，因此main()函数的返回值并不是返回给程序的其他部分，而是返回给操作系统；
         - <font color=red>通常约定的是返回值（退出值）为0则意味着程序运行成功，为非零则意味着存在着问题。</font>

2. 函数的原型(prototype)和调用

   - 为什么需要原型？
     
     - 函数原型对函数来说，就相当于变量的变量声明；
     - <font color=red>在使用函数前，C++编译器必须直到函数的参数类型和返回值类型，如果缺少这些信息，编译器不知道如何解释返回值；</font>
     - 原型描述了函数到编译器的接口，也就是说，它将函数返回值得类型（如果有）以及参数的类型和数量告诉编译器。
     
   - 原型的语法
     - 获取原型最简单的方法是复制函数定义中的函数头，并添加分号；
     - <font color=red>函数原型不要求提供变量名，有类型列表就行，也可以将变量名包括进去。</font>
     
     <p style="color:blue;background-color:gray;text-align:center;">typeName1  functionName(typeName2);</p>
     - typeName1表示的是将返回一个此类型的值，括号中的typeName2表示函数需要的参数的类型。
     
   - <font color=blue>原型的功能</font>
     
     - 原型确保以下几点工作：
       - 编译器正确处理函数返回值；
       - 编译器检查使用的参数数目是否正确；
       - 编译器检查使用的参数类型是否正确。



## 5.2 函数参数和按值传递

- C++通常按值传递参数，这意味着<font color=blue>将数值参数传递给函数，而函数会将其赋给一个新的变量；</font>

  - <font color=red>用于接收传递值得变量称为形参，</font><font color=blue>传递给函数的值称为实参；</font>出于简化，C++用参数(argument)表示实参，用参量(parameter)来表示形参，<font color=red>因此参数传递将参数赋给参量。</font>

    <img src=".\img\按值传递.png" alt="按值传递" style="zoom:80%;" />

    <center>图5.1 按值传递</center>

  - 在函数中声明的变量（包括参数）是该函数私有的；

    - 在函数调用时，计算机将为这些变量分配内存；
    - 在函数结束时，计算机将释放这些变量使用的内存；
    - 这样的变量成为局部变量，它们被限制在函数中，这样做有助于确保数据的完整性。

1. **多个参数**
   - 函数中可以有多个参数，在调用函数时，只需<font color=red>使用逗号将这些参数分开即可</font>；
   - 在函数定义的使用也使用逗号将参数声明进行隔开；

## 5.3 函数和数组

- 要将数组传递给函数，需要将函数定义中对应的形参名称命名为数组。

1. **函数如何使用指针来处理数组**

   - 大多数情况下，C++与C一样，也<font color=blue>将数组名视为指针，将数组名解释为其第一个元素的地址，</font>但是这个规则有一些例外：
     - 数组声明使用数组名来标记存储位置；
     - 对数组名使用sizeof将得到整个数组的长度（以字节为单位）；
     - 将地址运算符&用于数组名时，将返回整个数组的地址。

   - 对于函数调用`int sum = sum_arr(cookies, Arsize);`
     - <font color=blue>cookies是数组名，cookies是其第一个元素的地址，因此函数传递的是地址；</font>
     - 由于数组元素的类型是int，所以cookies的类型必须是int指针，即int\*，所以，正确的函数头应该是`int sum_arr(int* arr,int n);`
       - 其中用`int* arr `替换了`int arr[]`，<font color=red>当用于函数头和函数原型中，`int* arr `和`int arr[]`的含义才是相同的；</font>
       - 它们都意味着arr是一个int指针，数组表示法(int arr[])提醒用户，arr不仅指向int，还指向int数组的第一个int；当指针指向数组的第一个元素时，用数组表示法，当指针指向一个独立的值时，使用指针表示法

2. **将数组作为参数意味着什么**

   - 并没有将数组内容传递给函数，而是将<font color=red>数组的位置（地址）、包含的元素种类（类型）以及元素数目提交给函数</font>，有了这些信息，函数便可以使用原来的数组；

     <img src=".\img\告知函数有关数组的相关信息.png" alt="告知函数有关数组的相关信息" style="zoom:75%;" />

     <center>图5.2 告知函数数组相关的信息</center>

   - 传递常规变量时，函数将使用该变量的拷贝；但是<font color=blue>传递数组时，函数将使用原来的数组；</font>

   - 数组名与指针对应的好处：

     - 将数组地址作为参数可以<font color=red>节省赋值整个数组所需的时间和内存</font>，如果数组很大，使用拷贝的系统将使用更多的时间和内存来赋值数据；<font color=red>使用原始数据增加破坏数据的风险。</font>

3. **使用数组区间的函数**
   - 另一种给函数提供数组信息的方法，即<font color=red>指定元素区间(range)</font>；
     - 这可以通过传递两个指针来完成：<font color=blue>一个指针标识数组的开头，另一个指针标识数组的尾部</font>

4. **指针和const**

   - 可以用两种不同的方式将const关键字用于指针；

     - 第一种是<font color=blue>让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值；</font>

       ```C++
       int age = 39;
       const int* pt = &age;
       ```

       - 该声明指出，pt指向一个const int，因此不能使用pt来修改这个值，换句话来说\*pt的值是const，不能修改，<font color=red>也就是说指针指向的那个地址是一个const，是不能做修改的；</font>但是可以通过直接修改age变量来修改age的值；

       - <font color=red>可以将consst变量的地址赋给指向const的指针；</font>

       - <font color=red>==但是不能==将const的地址赋给常规指针；</font>

         ```C++
         const float g_earth = 9.80;
         const float* pe = &g_earth;//valid
         
         const float g_moon = 1.63;
         float* pm = &g_moon;//invaild
         ```

         - 对于第二种情况，那么就可以使用pm修改g_moon的值，与g_moon是const冲突。

     - 第二种是<font color=blue>将指针本身声明为常量，这样可以防止改变指针指向的位置</font>

## 5.4 函数和二维数组

- 数组名被视为其地址，因此，相应的形参是一个指针，就像一维数组一样。<font color=red>比较难处理的是如何正确地声明指针；</font>假设有以下代码：

  ```C++
  int data [3][4] = {{1,2,3,4},{6,5,4,7},{9,8,7,6}};
  int total = sum(data,3);
  ```

  - data是一个数组名，该数组有3个元素，第一个元素有4个int的数据，<font color=blue>因此data的类型是指向由4个int组成的数组的指针，</font>其正确的原型为：`int sum(int (*ar2)[4], int size);`其中的括号是必不可少的；
  - 还有另外一种格式：`int sum(int ar2[][4], int size);`
  - <font color=red>上面两种方式都指出，ar2是指针不是数组，</font>指针类型指出，它指向由4个int组成的数组，<font color=red>因为传递数组时，==不会指定数组数组的长度==，所以`arr2[][4]`的第一个括号为空。</font>

## 5.5 函数和C-风格字符串

- C-风格字符串是由一系列字符组成，以空字符结尾，大部分有关设计数组函数的知识也适用于字符串函数；
  - 例如，<font color=red>将字符串作为参数时意味着传递的是地址，但是可以使用const来禁止对字符串参数进行修改。</font>

1. **将C-风格字符串作为参数的函数**

   - 要将字符串作为参数传递给函数，表示字符串的方式有3种：

     - char数组；

     - 用引号括起来的字符串常量；

     - 被设置为字符串的地址的char指针

       <font color=blue>但上述3种选择的类型都是char指针（准确说是char*），因此可以将其作为字符串处理函数的参数。</font>

   - 可以说是将字符串作为参数来传递，但<font color=red>实际传递的是字符串的第一个字符</font>，这意味着字符串函数原型应将其表示为字符串的形参声明为char*类型。

   - C-风格字符串与常规char数组之间的一个重要的区别是：<font color=blue>字符串有内置的结束字符，</font>这意味着不必将字符串的长度作为参数传递给函数，而函数可以使用循环一次检查字符串中的每一个字符，直到遇到结尾的空字符为止；

     - 处理字符串中字符的标准方式：

       ```
       while (*str)
       {
       	statements
       	str++;
       }
       ```

       - str最初指向字符串的第一个字符，因此\*str表示的是第一个字符，只要字符不是空值字符(\0)，\*str就为非零值，循环就将继续；
       - 在每轮循环的结尾，表达式str++将指针增加一个字节，使之指向字符串的下一个字符，最终将指向空字符(\0)，使得\*str的值为0，结束循环。

2. **返回C-风格字符串的函数**

   - <font color=red>函数无法返回一个字符串，但是可以返回字符串的地址，这样做效率更高。</font>

## 5.6 函数和结构

- 与数组不同，<font color=red>结构将其数据组合成单个实体或数据对象，该实体将被视为一个整体</font>
  - 可以将一个结构赋给另一个结构；同样也可以按值传递结构，这种情况下，函数使用的是原始结构的副本；
  - 另外，函数可以返回结构；
  - <font color=blue>与数组名就是数组第一个元素的地址不同，结构名只是结构的名称，==要获得结构的地址，必须使用地址运算符&==</font>

- 在使用结构编程时，最直接的方式是像处理基本类型那样来处理结构，也就是说将结构作为参数传递，并在需要时将结构用作返回值；
  - 按值传递有一个缺点，如果结构非常大，则复制结构将要加大内存要求，降低系统运行速度，<font color=red>所以更倾向于传递结构的地址，然后使用指针来访问结构的内容；</font><font color=blue>C++第三种方法，提供了按引用传递</font>

1. **传递和返回结构**
   - 当结构比较小时，按值传递结构最合理；
   - 向函数传递结构和处理基本类型相同。

2. **传递结构的地址**

   - 假设要传递结构的地址而不是整个结构以节省时间，则需要使用指向结构的指针，比较前面而言，需要修改的有3个地方：
     - 调用函数时，将结构的地址(&pplace)而不是结构本身(pplace)传递给它；
     - 将形参声明为指向polar（结构名称）的指针，即polar\*类型；
     - <font color=red>由于==形参是指针而不是结构==，因此使用间接成员运算符(->)，而不是成员运算符（句点）。</font>

   - 使用指针传递之后，函数不返回一个新的结构，而是修改调用函数中已有的结构。

## 5.7 函数和string对象

- 与数组相比，string对象与结构更相似，例如，<font color=red>可以将一个结构赋值给另一个结构，也可以将一个对象赋值给另一个对象；可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递；</font>如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。

## 5.8 函数和array对象

- 在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类，<font color=red>例如，可以按值将对象传递给数组，这时函数处理的是原始对象的副本；另外也可以传递对象的指针，这样函数就可以操作原始对象。</font>

## 5.9 递归

- C++函数一个有趣的特点——自己调用自己，（与C语言不同的是C++不允许main()调用自己），这种功能称为递归；

1. **包含一个递归调用的递归**
2. **包含多个递归调用的递归**
   - 在需要将一项工作不断分为两项较小的、类似的工作时，递归非常有用。

## 5.10 函数指针

- 与数据项类似，函数也有地址，<font color=red>函数的地址是存储其机器语言的代码的内存的开始地址。</font>

1. **函数指针的基础知识**

   - 将函数的地址进行传递给另一个函数，要完成以下工作：
     - 获取函数的地址；
     - 声明一个函数指针；
     - 使用函数指针来调用函数。

   1. **获取函数地址**

      - 获取函数地址，==只要使用函数名==（后面不跟参数）；

        ```C++
        //think为一个函数的名称；
        process(think);//传递的是函数think的地址
        thought(think());//传递的是函数think的返回值
        ```

   2. **声明函数指针**
      
- 声明函数的指针时，也必须要指定指针指向的函数类型，<font color=blue>这意味着声明应指定函数的返回类型以及函数的特征标（参数列表），也就是说声明应像函数原型那样指出有关函数的信息；</font>
      
   3. **使用指针来调用函数**



# 六、对象和类

- 面向对象编程(OOP)是一种特殊的、设计程序的概念性方法。<font color=blue>最重要的OOP特性：</font>
  - 抽象；
  - 封装和隐藏数据；
  - 多态；
  - 继承；
  - 代码的可重用性。

- 为了实现这些特性并将它们组合在一起，C++做的重要的事情就是提供了<font color=red>类</font>。

## 6.1 过程性编程和面向对象编程

- <font color=blue>过程性编程</font>
  - 首先考虑要遵循的步骤；
  - 然后考虑如何表示这些数据。
- <font color=blue>面向对象编程</font>
  - 首先考虑数据——如何表示数据以及如何使用数据。
  - 确定如何实现接口和数据的存储。

## 6.2 抽象和类

- 在计算中，为了根据信息与用户之间的接口来表示它，抽象是至关重要的，抽象是通往用户定义类型的捷径，<font color=red>在C++中，用户定义类型指的是实现抽象接口的类设计。</font>

1. **类型是什么**

   - <font color=red>指定类型完成了三项工作：</font>
     - 决定数据对象需要的内存数量；
     - 决定如何解释内存中的位（long和float在内存中占用的位数相同，但是将它们转换成数值的方法不同）；
     - 决定可使用数据对象执行的操作或方法。
     - <font color=blue>对于内置类型来说，有关的操作信息被内置到编译器中；但是C++中自己定义的类型时，必须自己提供这些信息。</font>

   

2. **C++中的类**

   - 类是一种将抽象转换成用户定义类型类型的C++工具，它将<font color=red>数据表示</font>和<font color=blue>操纵数据的方法</font>组合成一个整洁的包。
   - 类的定义。<font color=blue>类规范由两个部分组成：</font>
     - <font color=red>类声明：</font>以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口；
     - <font color=red>类方法定义：</font>描述如何实现类成员函数。
     - <font color=blue>简单说，类声明提供了类的蓝图，方法定义则提供了细节。</font>

   - 通常，<font color=red>将接口（类定义）放在头文件中，</font><font color=blue>并将实现（类方法的代码）放在源代码文件中。</font>
   - 一个常见的约定——将类名首字母大写。

   <img src="F:\学习\编程语言相关\C plus plus\img\Stock class.png" alt="Stock class" style="zoom: 80%;" />

   <center>图6.1 Stock 类</center>
- 从图6.1 类的构造可知：
  
  - C++关键字class指出这些代码定义了一个类设计，<font color=red>指出了Stock 是这个新类的类型名，该声明可以让我们能够声明Stock类型的变量——称为对象或实例。</font>
  
  1. **访问控制**
  
     ==关键字private和public描述了对类成员的访问控制。==
  
     - <font color=blue>使用类对象的程序可以直接访问公有部分，</font><font color=red>但只能通过公有成员函数（或友函数）来访问对象的私有成员；</font>
        - 防止程序直接访问的数据称为数据隐藏；
        - C++还有控制访问的关键字protected；
        - 类设计尽可能地将公有接口和实现细节分开。
  
  2. <font color=red>封装的例子</font>
  
     - 数据隐藏（将数据放在类的私有部分中）是一种封装；
        - 将实现的细节隐藏在私有部分中是一种封装；
        - 将类函数定义和类声明放在不同的文件中是一种封装。
  
  3. **控制对成员的访问：公有还是私有**
  
     - 隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分；组成类接口的成员函数放在公有部分，否则就无法从程序中调用这些函数。
        - <font color=red>不必在类声明中使用关键字private，因为类对象的默认访问控制</font>
  
3. **实现类成员函数**

   - 创建类描述的第二部分：为那些由类声明中的原型表示的类成员函数提供代码。
   - 成员函数定义与常规函数定义相似，它们有函数头和函数体，也可以有返回类型和函数，<font color=blue>但是它们有两个特殊的特征：</font>
     - 定义成员函数时，使用<font color=red>作用域解析运算符(::)</font>来标识函数所属的类；
       - 作用域解析运算符确定了方法对应的类的身份。
     - 类方法可以访问类的private组件。

   

   <img src="F:\学习\编程语言相关\C plus plus\img\对象、数据和成员函数.png" alt="对象、数据和成员函数" style="zoom:80%;" />

   <center>图6.2 对象、数据和成员函数</center>
- 创建的每一个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一种类方法，即每一种方法只有一个副本。
   - <font color=blue>在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，</font>该方法被用于两个不同的对象（如图6.2）。
   
4. **使用类**
   - C++的目标是使得使用类与使用基本的内置类型（如int和char）尽可能相同；
   - 要创建类对象，可以声明类变量，也可以使用new为类对象分配存储空间；可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。
   - <font color=red>使用新类型，最关键的是要了解成员函数的功能，而不必考虑其实现细节。</font>

5. **修改实现**



6. ==**Summary**==

   - 指定类设计的<font color=blue>第一步是提供类声明，</font>类声明包括数据成员和函数成员；
     - 通常，数据成员被放在私有部分中，成员函数被放在公有部分中；
     - 公有部分的内容构成了设计的抽象部分——公有接口。

   - <font color=blue>第二步是实现类函数的类成员函数；</font>
     - 可以在类声明中提供完整的函数定义，而不是函数原型，但<font color=red>通常的做法是单独提供函数定义。</font>

## 6.3 类的构造和析构函数

- C++提供了一个特殊的成员函数——==类构造函数==，<font color=red>专门用于构造新对象、将值赋给他们的数据成员；</font><font color=blue>更确切地说，C++为这些成员函数提供了名称和使用语法，而程序员需要提供定义。</font>名称与类名相同。
- <font color=red>构造函数虽然没有返回值，但没有被声明为void类型。实际上，构造函数没有声明类型。</font>

1. **声明和定义构造函数**

   

2. **使用构造函数**

   1. 显式地调用构造函数；
   2. 隐式地调用构造函数。

3. **默认构造函数**

   - 默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。

4. **析构函数**

   - 用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个<font color=blue>特殊的成员函数——析构函数</font>来完成清理工作；
   - 如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存；如果构造函数未使用new来分配内存，<font color=red>因此析构函数就没有需要完成的任务，这种情况下，让编译器生成一个什么都不做的隐式析构函数即可。</font>
   - 析构函数的名称是在类名之前加上“~”；和构造函数一样，析构函数也没有返回值和声明类型，与构造函数不同的是，析构函数没有参数。



## 6.4 this指针

- this是C++中的一个关键字，也是一个常量指针，指向当前对象（具体说是当前对象的首地址）；通过this，可以访问当前对象的成员变量和成员函数；
- **this** 指针是只能在 **class**、struct或 **union** 类型的非静态成员函数中访问的指针。 它指向为其调用成员函数的对象。 静态成员函数没有 **this** 指针。

## 6.5 对象数组

- <font color=blue>声明对象数组的方法与声明标准类型的数组相同；</font>



## 6.6 类作用域



## 6.7 抽象数据类型



# 七、使用类

## 7.1 运算符重载

- C++根据操作数的数目和类型来决定采用哪种类型；
- 要重载运算符，需使用被称为运算符函数的特殊函数形式，运算符函数的格式：`operator op(arguement-list)`，op必须是C++中有效的运算符，例如`operator +()`重载+运算符。

1. **重载限制**

   - 多数的运算符都可以用这样的方式重载，<font color=red>重载的运算符不必是成员函数，但是必须至少有一个操作数是用于定义的类型</font>；

   - C++对重载的限制：

     - 重载后的运算符必须至少有一个操作数是用户定义的类型，这防止用户为标准类型重载运算符，<font color=blue>例如不能将减法运算符(-)重载为两个数的和，而不是它们的差；</font>这可以保证程序正常运行；
     - 使用运算符时不能违反运算符原来的句法规则，例如不能将求模运算符(%)重载使用一个操作数；同样不能修改运算符的优先级；
     - <font color=blue>不能创建新的运算符；</font>
     - 不能重载下面的运算符：
       - sizeof： sizeof运算符；
       - . ： 成员运算符；
       - .\*： 成员指针运算符；
       - :: ：作用域解析运算符；
       - ?:：条件运算符；
       - typeid：一个RTTI运算符；
       - const_cast, dynamic_cast, reinterpret_cast, static_cast：强制类型转换运算符；

     - 大部分运算符可以通过成员或非成员函数进行重载，但是下面的运算符只能通过成员函数进行重载：
       - =：赋值运算符；
       - ()：函数调用运算符；
       - [ ]：下标运算符；
       - ->：通过指针访问类成员的运算符。

## 7.2 友元

## 7.3 重载运算符

## 7.4 类的自动转换和强制类型转换



# 十、输入、输出和文件

## 10.1 C++输入和输出概述

- C++依赖于C++的I/O解决方案，而不是C语言的I/O解决方案；<font color=blue>C++的I/O解决方案是在头文件iostream和fstream中定义一组类。</font>这个类库不是正式语言定义的组成部分（cin和istream不是关键字）。

1. **流和缓冲区**

   <p style="background-color:gray;text-align:center;"><strong>流</strong></p>
- <font color=red>C++程序把输入和输出看作字节流：</font>
     - 输入时，程序从输入流中抽取==字节==；
     - 输出时，程序将==字节==插入到输出流中；
     - 对于面向文本的程序，每个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二进制表示。
   
- 输入流中的字节可能来自于键盘、也可能来自于存储设备；同样，输出流中的字节可以流向屏幕、打印机或存储设备；<font color=red>流充当了程序和流源或流目标之间的桥梁。</font>这使得C++可以以相同的方式来对待来自键盘的输入和来自文件的输入。
   - <font color=red>C++程序只是检查字节流，而不需要知道字节来自何方；同理，通过使用流，C++程序处理输出的方式将独立于其去向。</font>因此管理输入包括两步：
     - 将流与输入去向的程序关联起来；
     - 将流与文件连接起来。
   

<img src="F:\学习\编程语言相关\C plus plus\img\C++输入和输出.png" alt="C++输入和输出" style="zoom:67%;" />

<center>图10.1 C++输入和输出</center>
   - 输入流需要两个连接，每端各一个，<font color=blue>文件端部连接提供了流的来源，程序端连接将流的输出部分转储到程序中</font>（文件连接端可以是文件，也可以是设备或键盘）；同样，<font color=red>对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。</font>

   <p style="background-color:gray;text-align:center;"><strong>缓冲区</strong></p>
   - 通过使用缓冲区可以更高效地处理输入和输出，<font color=red>缓冲区是用作中介的内存块，它将信息<font color=blue>从设备传输到程序</font>或<font color=blue>从程序传输到设备</font>的临时存储工具；</font>
   - ==**缓冲区帮助匹配两种不同的信息传输速率；**==
     - 从磁盘文件中每次读取一个字符需要大量的硬件活动，速度非常慢，<font color=red>缓冲方法则从磁盘上读取大量的信息，将这些信息存储在缓冲区中，然后每次从缓冲区里读取一个字节；</font>
     - <font color=red>输出时，程序首先填满缓冲区，然后把整块数据传给硬盘，并清空缓冲区，以备下一批输出使用。</font>这被称为刷新缓冲区(flashing the buffer)。

	<img src="F:\学习\编程语言相关\C plus plus\img\有缓冲区的流.png" alt="有缓冲区的流" style="zoom:67%;" />
	
	<center>图10.2 有缓冲区的流</center>
   - 键盘输入每次提供一个字符，在这种情况下，程序无需缓冲区来帮助匹配不同的数据传输速率，然而，对键盘输入进行缓冲可以让用户在将输入传输给程序之前返回并更正，<font color=blue>C++程序通常在用户按下回车键时刷新输入缓冲区；</font>
   - 对于屏幕输出，<font color=blue>C++程序通常在用户发送换行符时刷新输出缓冲区。</font>

2. **流、缓冲区和iostream文件**

- 管理流和缓冲区的工作有点复杂，但iostream文件中包含一些专门设计用来实现、管理流和缓冲区的类。

<img src="F:\学习\编程语言相关\C plus plus\img\一些IO类.png" alt="一些IO类" style="zoom: 67%;" />

<center>图10.3 一些I/O类</center>
- 其中的一些类：
  
  - streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；
     - ios_ base类表示流的一般特征， 如是否可读取、是二进制流还是文本流等；
     - ios类基于ios_base,其中包括了一一个指向streambuf对象的指针成员；
     - ostream类是从ios 类派生而来的，提供了输出方法；
     - istream类也是从ios类派生而来的，提供了输入方法；
     - iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。
  
  <font color=red>要使用这些工具，必须使用适当的类对象，例如，使用ostream对象（如cout）来处理输出。</font>创建这样的对象将打开一个流，自动创建缓冲区，并将其与流关联起来，同时使得能够使用类成员函数。
  
   - C++中的iostream类库管理了很多细节。例如，<font color=blue>在程序中包含iostream文件将自动创建8个流对象（4个用于窄字符流，4个用于宽字符流）。</font>
  
     - cin对象对应于标准输入流。在默认情况下，这个流被关联到标准输入设备(通常为键盘)。wcin对象与此类似，但处理的是wchar_t类型；
     - cout对象与标准输出流相对应。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。wcout对象与此类似，但处理的是wchar_t类型；
     - cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。wcerr 对象与此类似，但处理的是wchar_ t类型；
     - clog对象也对应着标准错误流。在默认情况下，这个流被关联到标准输出设备(通常为显示器)。这个流被缓冲。wclog 对象与此类似，但处理的是wchar_t类型；
     - 对象代表流——这意味着什么呢? 当iostream文件为程序声明一个cout对象时，该对象将包含存储了与输出有关的信息的数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法以及描述用来处理输出流的缓冲区的streambuf 对象的地址。下面的语句通过指向的streambuf对象将字符串“Bjarna fee”中的字符放到cout管理的缓冲区中：cout << "Bjarne free";
  
     ostream类定义了上述语句中使用的operator<<( )函数，ostream 类还支持cout数据成员以及其他大量的类方注。另外，C++注意到，来自缓冲区的输出被导引到标准输出。<font color=red>总之，流的一端与程序相连，另一端与标准输出相连，cout对象凭借streambuf对象的帮助，管理着流中的字节流。</font>

3. **重定向**
   - <font color=red>标注输入和输出流通常连接着键盘和屏幕，</font>但很多操作系统都支持重定向，这个工具使得能够改变标准输入和标准输出。

## 10.2 使用cout进行输出

- C++将输出看作字节流，但是在程序中，很多数据被组织成比字节更大的单位；
  - 如int类型由16位或32位的二进制表示，double值由64位的二进制数据表示；
  - 但在<font color=red>将字节流发送给屏幕时，希望每个字节表示一个字符值，</font>如要显示-2.34，需要将5个字符(-、2、.、3和4)，而不是这个值得64位内部浮点表示发送到屏幕上；
  - 因此，ostream类最重要的任务之一是<font color=blue>将数值类型（如int或float）转换为以文本表示的字符流，</font>也就是说，<font color=red>ostream类将数据内部表示（二进制位模式）转换为由字符字节组成的输出流。</font>

1. **重载的<<运算符**

   - 在C++中，与C一样，<<运算符的默认含义是<font color=red>按位左移运算符</font>，但是ostream类<font color=blue>重新定义了<<运算符</font>，方法是将它重载为输出，在这种情况下，<font color=blue><<叫做插入运算符</font>，而不是左移运算符；插入运算符被重载，使之能够识别C++所有的基本类型：

     - unsigned char;
     - signed char;
     - char;
     - short;
     - unsigned short;
     - int;
     - unsigned int;
     - long;
     - unsigned long;
     - long long (C++11);
     - unsigned long long (C++11);
     - float;
     - double;
     - long double

     <font color=red>对于上述每种数据类型，ostream类都提供了operator<<()函数的定义</font>，因此，执行下面这样一条语句，而value是前面列出来的类型之一，则C++程序将其对应于有相应的特征标的运算符的运算符函数:

     `cout << value;`

     例如，表达式`cout << 88;`对应于下面的函数原型：`ostream & operator << (int);`

     <font color=blue>该原型表明：</font>

     - operator<<()函数接受一个int参数，这与上述语句的88匹配；
     - <font color=red>函数返回一个指向ostream对象的引用，这使得可以将输出连接起来。</font>

   1. 输出和指针

      - ostream类还为指针类型定义了插入运算符函数：
        - const signed char \*;
        - const unsigned char \*;
        - const char \*;
        - void \*。

      <font color=blue>C++用指向字符串存储位置的指针来表示字符串，指针的形式可以是cha数组、显示的char指针或用引号括起来的字符串。</font>

   2. 拼接输出

      - 插入运算符的所有化身的返回类型都是ostream &，原型的格式如下：`ostream & operator<<(type);`，返回类型ostream & 意味着使用该运算符将返回一个指向ostream对象的引用；

      - 函数定义指出，引用将指向用于调用该运算符的对象，也就是说，<font color=blue>运算符函数的返回值为调用运算符的对象。</font>

        <img src="F:\学习\编程语言相关\C plus plus\img\拼接输出.png" alt="拼接输出" style="zoom:67%;" />

        <center>图10.4 拼接输出</center>

2. **其他ostream方法**

   - 除了各种operator<<()函数外，ostream类还提供了put()方法和write()方法；
     - put()方法：用于显示字符；
       - 原型：`ostream & put(char);`
       - 可以用类方法调用它：`cout.put('w');`
       - 和<<运算符一样，该函数也返回一个指向调用对象的引用，因此可以用它将拼接输出，`cont.put().put()`。
     - write()方法：用于显示整个字符串；
       - 原型：`basic_ostream<charT,traits>& write(const char_type* s,streamsize n);`
       - <font color=red>write()的第一个参数提供了要显示的字符串的地址，第二个参数指出了要显示多少个字符；</font>
       - 可以用类方法调用它：`cout.write(const char_type* s,streamsize n);`
       - `cout.write()`调用返回cout对象，这是因为write()方法返回一个指向它的对象的引用，这里调用它的对象是cout，这使得可以将输出拼接起来；
       - <font color=blue>write()方法并不会在遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出了字符串的边界！</font>

3. **刷新输出缓冲区**

4. **用cout进行格式化**

   - ostream插入运算符将值转换为文本格式。在默认情况下，格式化值的方式如下。

     - 对于char值，如果它代表的是可打印字符，则将被作为一个字符显示在宽度为一个字符的字段中。

     - 对于数值整型，将以十进制方式显示在一个刚好容纳该数字及负号(如果有的话)的字段中。

     - 字符串被显示在宽度等于该字符串长度的字段中。

       <font color=red>浮点数的默认行为有变化，下面详细说明了老式实现和新实现之间的区别：</font>

     - <font color=blue>新式：</font>浮点类型被显示为6位，末尾的0不显示(注意，显示的数字位数与数字被存储时精度没有任何关系)。数字以定点表示法显示还是以科学计数法表示(参见第3章)，取决于它的值。具体来说，当指数大于等于6或小于等于-5时，将使用科学计数法表示。另外，字段宽度恰好容纳数字和负号(如果有的话)。默认的行为对应于带%g说明符的标准C库函数fprintf( )。

     - <font color=blue>老式：</font> 浮点类型显示为带6位小数，末尾的0不显示(注意，显示的数字位数与数字被存储时的精度没有任何关系)。数字以定点表示法显示还是以科学计数法表示(参见第3章)，取决于它的值。另外，字段宽度恰好容纳数字和负号(如果有的话)。

       因为每个值的显示宽度都等于它的长度，因此必须显式地在值之间提供空格；否则，相邻的值将不会被分开。

   1. **修改显示时使用的计数系统（改变进制）**

      - ostream类是从ios类派生而来的，而ios类是从ios_base类派生而来的，ios_base类存储了描述格式状态的信息；
        - 例如，一个类成员中某些位决定了使用的计数系统，而另一个成员则决定了字段宽度；
        - <font color=red>通过使用控制符(manipulator)，可以控制显示整数时使用的计数系统；</font>
        - 通过使用ios_base的成员函数可以控制字段宽度和小数位数，<font color=blue>由于ios_base类是ostream的间接基类，因此可以将其方法用于ostream对象（或子代），如cout。</font>

      - ==如何设置显示整数时使用的计数系统？==
        - 要控制整数以十进制、十六进制还是八进制显示，可以使用<font color=red>dec、hex和oct控制符</font>；
        - 控制符的使用格式为`hex(cout)`，但是它们的通常使用格式是`cout << hex;`，这两种方式等价；
        - <font color=blue>控制符函数不是成员函数，因此不必通过对象来调用；控制符位于名称空间std中；</font>
        - ==在使用时可以单独使用控制符，也可以作为一系列插入的组成部分。==

   2. **调整字段宽度**

      - 程序输出的各列不能对齐，是因为<font color=red>数字的字段宽度不同</font>，可以使用width成员函数将长度不同的数字放到宽度相同的字段中；
      - width方法的原型为：
        - `int width();`返回字段宽度的当前设置；
        - `int width(int i);`将字段宽度设置为i个空格，并返回以前的字段宽度，<font color=blue>这是得可以保存以前的值，以便以后恢复宽度值时使用。</font>
      - width()是成员函数，必须使用对象来调用它；
      - <font color=red>width()方法只影响将显示的下一个项目，然后字段宽度恢复默认值。</font>
      - <font color=red>C++永远不会截断数据，</font>如果在宽度为2的字段中打印一个7位值，C++将增宽字段，C++的默认字段宽度为0。

   3. **填充字符**

      - 默认情况下，cout使用空格来填充字段中未被使用的部分，<font color=red>可以使用fill()成员函数来==改变==填充字符</font>，例如使用\*填充：`cout.fill('*');`
      - 新的填充字符一直有效，直到下一次修改。

   4. **设置浮点数的精度**

      - 浮点数的输出精度取决于输出模式，默认模式下，它指的是显示的总位数，<font color=red>在定点模式和科学模式下，精度指的是小数点后面的位数。</font>
      - C++默认精度为6位（但末尾的0将不显示）；
      - precision()成员函数使得能选择其他的值，如`cout.precision(2)`将cout的精度设置为2，<font color=red>设置的精度一直有效</font>。

   5. **打印末尾的0和小数点**

      - ios_base类提供了一个<font color=blue>setf()函数，能够控制多种格式化特性，这个类还定义了多个常量，可以用作该函数的参数，</font>
        - 如`cout.setf(ios_base::showpoint);`可以显示末尾小数点；
        - 使用默认的浮点格式时，上述语句还会将末尾的0被显示出来；

   6. **再谈setf()**

      - setf()方法控制了小数点被显示时其他几个格式选项；
      - <font color=blue>ios_base类有一个受保护的数据成员，其中的各位（这里叫做类标记）分别控制着格式化的各个方面，如计数系统、是否显示末尾的0等等。</font>
        - <font color=red>打开一个标记称为称为设置标记（或位）</font>，并意味着相应的位被设置为1；
        - 位标记是编程开关，相当于设置DIP开关以配置计算机硬件，例如，hex、dec和oct控制符调整控制计数系统的3个标记位，setf()函数提供了<font color=red>另一种调整标记位的途径。</font>
	   - setf()函数有两个原型，第一个是：
        - `fmtflags setf(fmtlags);`
	     - fmtflags是bitmask类型的typedef名，用于存储格式标记；
	     - 这个版本的setf()<font color=red>用来设置单个位控制的格式信息</font>；ios_base类定义了代表位值的常量，下面是其中的一些定义：
   
      | 常量                | 含义                                  |
      | ------------------- | ------------------------------------- |
      | ios_base::boolalpha | 输入和输出bool值，可以为true和false   |
      | ios_base::showbase  | 对于输出，使用C++基数前缀(0, 0x)      |
   | ios_base::showpoint | 显示末尾的小数点                      |
      | ios_base::uppercase | 对于16进制输出，使用大写字母，E表示法 |
   | ios_base::showpos   | 在正数前加+                           |
   
      - 第二个setf()原型接受两个参数，并返回以前设置的值：
        - `fmtflags setf(fmtlags, fmtlags);`
        - 函数的这种格式用于<font color=red>设置由多位控制的格式选项；</font>第一个参数包含了所需设置的fmtflags值，第二个参数指出要清楚第一个参数中的哪些位；ios_base类为此定义了常量：
   
      <table>
      	<tr>
              <th><center>第二个参数</center></th>
              <th><center>第一个参数</center></th>
              <th><center>含义</center></th>  
      	</tr >
      	<tr >
      	    <td rowspan="3">ios_base ::basefield</td>
      	    <td>ios_base ::dec</td>
      		<td>使用基数10</td>
      	</tr>
      	<tr>
      	    <td>ios_base ::oct</td>
      		<td>使用基数8</td>
      	</tr>
      	<tr>
      	    <td>ios_base ::hex</td>
      		<td>使用基数16</td>
      	</tr>
      	<tr >
      	    <td rowspan="2">ios_base ::floatfield</td>
      	    <td>ios_base ::fixed</td>
      		<td>使用定点计数法</td>
      	</tr>
      	<tr>
      	    <td>ios_base ::scientific</td>
      		<td>使用科学计数法</td>
      	</tr>
      	<tr >
      	    <td rowspan="3">ios_base ::adjustfiled</td>
      	    <td>ios_base ::left</td>
      		<td>使用左对齐</td>
      	</tr>
      	<tr>
      	    <td>ios_base ::right</td>
      		<td>使用右对齐</td>
      	</tr>
      	<tr>
      	    <td>ios_base ::internal</td>
      		<td>符号或基数前缀左对齐，值右对齐</td>
      	</tr>
      </table>
   
      - 定点表示法意味着使用格式123.4来表示浮点值，而不管数字的长度如何，科学表示法意味着使用格式1.23e04，而不考虑数字的长度；
      - <font color=red>在C++中，定点表示法和科学表示法都有下面的两个特征：</font>
        - 精度指的是小数点位数，而不是总位数；
        - 显示末尾的0。
   
      - setf()函数是ios_base类的一个成员函数，由于这个类是ostream类的基类，因此<font color=red>可以使用cout对象来调用该函数</font>。

7. **标准控制符**

   - 使用setf()不是进行格式化的、对用户最友好的方法，<font color=red>C++提供了多个控制符，能够调用setf()，并自动提供正确的参数。</font>就像前面的dec、hex和oct。下面是其他的一些控制符：

     | 控制符      | 调用                                            |
     | ----------- | ----------------------------------------------- |
     | boolalpha   | setf(ios_base::boolalpha)                       |
     | unboolalpha | unsetf(ios_base::boolalpha)                     |
     | showbase    | setf(ios_base::showbase)                        |
     | unshowbase  | unsetf(ios_base::showbase)                      |
     | showpoint   | setf(ios_base::showpoint)                       |
     | unshowpoint | unsetf(ios_base::showpoint)                     |
     | showpos     | setf(ios_base::showpos)                         |
     | unshowpos   | unsetf(ios_base::showpos)                       |
     | uppercase   | setf(ios_base::uppercase)                       |
     | unuppercase | unsetf(ios_base::uppercase)                     |
     | internal    | setf(ios_base::internal,ios_base::adjustfield)  |
     | left        | setf(ios_base::left,ios_base::adjustfield)      |
     | right       | setf(ios_base::right,ios_base::adjustfield)     |
     | dec         | setf(ios_base::dec,ios_base::basefield)         |
     | hex         | setf(ios_base::hex,ios_base::basefield)         |
     | oct         | setf(ios_base::oct,ios_base::basefield)         |
     | fixed       | setf(ios_base::fixed,ios_base::floatfield)      |
     | scientific  | setf(ios_base::scientific,ios_base::floatfield) |

8. **头文件iomanip**

   - C++在头文件iomanip中提供了其他的一些控制符，他们能够提供前面的服务，但是表达起来更加方便；
   - <font color=red>3个最常用的控制符分别是setprecision()、setfill()、setw()，</font>它们分别用来设置精度、填充字符和字段宽度；
   - 与前面讨论的控制符不同的是，<font color=red>这3个控制符带参数：</font>
     - setprecision()控制符接受一个指定精度的<font color=blue>整数参数</font>；
     - setfill()控制符接受一个指定填充字符的<font color=blue>char参数</font>；
     - setw()控制符接受一个指定自字段宽度的<font color=blue>整数参数</font>。

   - 由于他们都是控制符，所以可以用cout语句连接起来。

## 10.3 使用cin进行输入

- <font color=red>cin对象将标准输入表示为字节流，</font>输入可以是字符串的一部分、int值、float值，也可以是其他类型。因此，抽取还涉及到类型转换，cin对象根据接收值的变量的类型，使用其方法将字符序列转换为所需的类型。

- 通常，可以这样用cin：

  `cin >> value_holder;`

  其中value_holder为存储输入的内存单元，他可以是变量、引用、被解除引用的指针，也可以是类或结构的成员。

- C++解释输入的方式取决于value_holder的数据类型；istream类重载了抽取运算符>>，使之能识别下面的基本类型：

  - unsigned char &;

  - signed char &;

  - char &;

  - short &;

  - unsigned short &;

  - int &;

  - unsigned int &;

  - long &;

  - unsigned long &;

  - long long  &(C++11);

  - unsigned long long & (C++11);

  - float &;

  - double &;

  - long double &。

    <font color=red>这些运算符函数被称为格式化输入函数(formatted iuput functions)，</font><font color=blue>因为他们可以将输入数据转化为目标指定的格式。</font>

    - 典型的运算符函数的原型如下：

      `istream & opreator>> (int &);`参数和返回值都是引用。

- istream类还为下列字符指针类型重载了>>抽取运算符：

  - signed char \*；

  - char \*；

  - unsigned char \*。

    <font color=red>对于这种类型的参数，抽取运算符将读取输入中的下一个单词，将它放到指定的位置，并加上一个空字符，使之成为一个字符串。</font>

- <font color=blue>每个抽取运算符都返回调用对象的引用，这使得能够将输入拼接起来。</font>

1. **cin>>如何检查输入**

   - 不同版本的抽取运算符查看输入流的方法是相同的，<font color=red>它们跳过空白（空格、换行符和制表符）到非空白字符。</font>即使对于单字符模式（参数类型为char、unsigned char和signed char）情况也是如此；

     - <font color=red>在单字符模式下</font>，>>运算符将读取该字符，将它放在指定的位置；

     - <font color=red>在其它模式下</font>，>>运算符将读取一个指定类型的数据，也就是说，<font color=blue>它读取从非空白字符开始，到与目标类型不匹配的第一个字符之间的全部内容。</font>

       <img src="F:\学习\编程语言相关\C plus plus\img\cin跳过空白字符.png" alt="cin跳过空白字符" style="zoom: 67%;" />

       <center>图10.5 cin>>跳过空白字符</center>

   - 对于下面的代码：

     - `int elevation;`

       `cin >> elevation;`

       假设键入下面的字符：-123z

     - 运算符将读取-、1、2和3，因为它们都是整数的有效部分，但是z不是有效字符，所以3就是接收的最后一个字符，z将会留在输入流中，下一个cin语句将从这里开始读取；

     - <font color=red>如果输入的字符是Zcar，不满足int条件，这时抽取运算符将不会修改elevation的值，并返回0。</font>

2. **流状态**

   - cin或cout对象包含一个描述流状态(stream state)的数据成员（从ios_base类那里继承的），<font color=red>流状态由3个ios_base元素组成：eofbit、badbit和failbit，其中每个元素是一位，也可以是1（设置）或0（清除）。</font>
     - 当cin到达文件末尾时，它将设置eofbit；
     - 当cin操作未能读取到预期字符时，它将设置failbit；
     - I/O失败（如试图将读取不可访问的文件），也可能将failbit设置为1；
     - 在一些无法诊断的失败破坏流时，badbit会被设置；
     - <font color=blue>当全部3个状态位都被设置为0时，说明一切顺利，程序可以检查状态流，并用这种信息来决定下一步做什么。</font>

   | 成员                    | 描述                                                         |
   | ----------------------- | ------------------------------------------------------------ |
   | eofbit                  | 如果到达文件尾，则设置为1                                    |
   | badbit                  | 如果流破坏，则设置为1；例如，文件读取错误                    |
   | failbit                 | 如果输入操作未能读取到预期的字符或输出操作没有写入预期字符，则设置为1 |
   | goodbit                 | 另一种表示0的方法                                            |
   | food()                  | 如果流可以使用（所有的位都被清楚），则返回true               |
   | eof()                   | 如果eofbit被设置，则返回true                                 |
   | bad()                   | 如果badbit被设置，则返回true                                 |
   | fail()                  | 如果badit或failbit被设置，则返回true                         |
   | rdstate()               | 返回流状态                                                   |
   | exceptions()            | 返回一个位掩码，指出哪些标记导致异常被引发                   |
   | exceptions(isostate ex) | 设置哪些状态将导致clear()引发异常；例如，如果ex是eofbit，则如果eofbit被设置，clear()将引发异常 |
   | clear(iostate s)        | 将流状态设置为s；s的默认值是0(goodbit)；如果(restate()& exceptions())!=0，则引发异常basic_ios::failsure |
   | setstate(iostate s)     | 调用clear(rdstate()\|s)。这将设置与s中设置的位对应的流状态位，其他流状态位保持不变 |

   1. 设置状态

      <p style="color:red;background-color:blue;">待补充</p>

   2. I/O和异常

   3. 流状态的影响

3. **其他istream类方法**

   - 关于get()和getline()方法：

     - 方法get(char &)和get(void)提供<font color=blue>不跳过空白的单字输入功能；</font>

     - 函数get(char\*,int,char)和getline(char\*,int,char)在<font color=blue>默认情况下读取整行而不是一个单词。</font>

       <font color=red>他们被称为非格式化输入函数(unformatted input functions)</font>，<font color=blue>因为它们只是读取字符输入，不会跳过空白，也不进行数据转换。</font>

   1. 单字符输入

      - <font color=red>在使用char参数或没有参数的情况下，get()方法读取下一个输入字符，即使该字符是空格、制表符或换行符；</font>
        - get(char & ch)版本将输入字符赋给其参数；
        - get(void)版本将输入字符转换为整型（通常是int），并将其返回。

      1. 成员函数get(char &)
         - 使用get(char &)，程序可以读取空白字符（空格、回车或换行符）；
         - 使用抽取运算符>>，将会跳过空白字符；
         - get(char &)成员函数会<font color=red>返回一个指向用于调用它的istream对象的引用，这就是说，可以拼接get(char &)后面的其他抽取。</font>如`cin.get(ch1).get(ch2) >> ch3;`
      2. 成员函数get(void)
         - get(void)成员函数还读取空白，但<font color=blue>使用返回值来将输入传递给程序</font>；
         - get(void)成员函数的返回值为int（或某种更大的整型，这取决于字符集和区域），<font color=red>返回值不是类对象，因此不能对它应用成员运算符，它的后面不能接抽取运算符。</font>

      - 单字符输入函数的区别：

        | 特征                     | cin.get(ch)           | ch=cin.get()       |
        | ------------------------ | --------------------- | ------------------ |
        | 传输输入字符的方法       | 赋给参数ch            | 将函数返回值赋给ch |
        | 字符输入是函数的返回值   | 指向istream对象的引用 | 字符编码(int值)    |
        | 到达文件尾时函数的返回值 | 转换为false           | EOF                |

   2. 采用哪种单字符输入

      - 如果需要跳过空白，使用抽取运算符>>；
      - 希望程序检查每个字符，使用get()，例如计算字数的程序可以使用空格来判断单词何时结束；

   3. 字符串输入：getline()、get()和ignore()

      - getline()成员函数和get()的字符串读取版本都读取字符串，它们的函数特征标相同：

        ```c++
        istream & get(char *,int, char);
        istream & get(char *,int);
        istream & getline(char *,int, char);
        istream & getline(char *,int);
        ```

        - <font color=blue>第一个参数是用于放置输入字符串的内存单元的地址；</font>
        - <font color=blue>第二个参数比要读取的最大字符数大1</font>（额外的一个字符用于存储结尾的空字符，以便将输入存储为一个字符串）；
        - <font color=blue>第三个参数指定用作分界符的字符</font>，只有两个参数的版本将换行符用作分界符；
        - <font color=red>上述函数都在读取最大数目的字符或遇到换行符后为止。</font>

      - get()和getlinr()的主要区别在于，<font color=blue>get()将（分界字符）换行符留在输入流中，这样接下来的操作首先看到的就是换行符</font>，<font color=red>而getline()抽取并丢弃输入流中的换行符。</font>

      - ignore()成员函数
        - 函数接受两个参数：第一个是数字，要读取的最大字符数，第二个是字符，用作输入分界符；例如`cin.ignore(255,'\n');`
        - 原型为：`istream & ignore(int=1,int=EOF);`
        - 函数返回调用对象，使得能够拼接函数调用。

   4. 意外字符串输入

      | 方法                  | 行为                                                         |
      | --------------------- | ------------------------------------------------------------ |
      | getline(char \* ,int) | 如果没有读取任何字符（但换行符被视为读取了一个字符），则设置failbit<br>如果读取了最大数目的字符，且行中还有其它字符，则设置failbit |
      | get(char \*,int)      | 如果没有读取任何字符，则设置failbit                          |

4. **其他istream方法**

   - 其他istream方法包括read()、peek()、gount()和putback()；

     - <font color=red>read()函数读取指定数目的字节，并将它们存储在指定的位置中；</font>
       - 使用方法`cin.read(ch,int);`ch表示数组名称；
       - read()方法最常与ostream write()函数结合使用，来完成文件的输入和输出，该方法的返回类型为istream &，因此可以拼接使用；
       - 与get()和getline()不同的是，<font color=blue>read()不会在输入后面添加空字符，因此不能将输入转换为字符串；</font>

     - <font color=red>peek()函数返回输入中的下一个字符，但不抽取输入流中的字符；</font>
       - 假设要读取输入，直到遇到换行符或句点，则可以使用peek()查看输入流中下一个字符，以此来判断是否进行读取。

     - <font color=red>gcount()方法返回最后一个<font color=blue>非格式化抽取方法</font>读取的字符数；</font>

     - <font color=red>putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符；</font>
       - putback()方法接受一个char参数——要插入的字符，其返回类型为istream &，这使得可以将该函数调用与其他istream方法拼接起来。

## 10.4 文件输入和输出

1. **简单的文件I/O**

   <p style="color=red;background-color:gray;">写文件</p>
- 要让<font coor=red>程序写入文件</font>，必须这样做：
  
  1. 创建一个ofstream对象来管理输出流；
     2. 将该对象与特定的文件关联起来；
     3. <font color=blue>以使用cout的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。</font>
  
  <font color=red>要完成上述任务，首先应包含头文件fstream，</font>对绝大多数实现来说，包含该文件就自动包含了iostream文件。
  
* 由于ostream是ofstream的基类，因此可以使用所有的ostream方法；
   * 以这种方式打开文件进行输出时，如果没有这样的文件，将创建一个新文件；如果有这样的文件，则打开文件将清空文件，输出将进入到一个空文件中。
   
<p style="color=red;background-color:gray;">读取文件</p>
   - 读取文件的要求与写入文件相似：

     1. 创建一个ifstream对象来管理输出流；
  2. 将该对象与特定的文件关联起来；
     3. <font color=blue>以使用cin的方式使用该对象。</font>
      
     
     <font color=red>首先要包含头文件fstream，然后声明一个ifstream对象，将它与文件名关联起来。</font>

   - 当输入和输出流对象过期（如程序终止）时，到文件的连接将自动关闭；另外也可以使用close()方法来显式地关闭到文件的连接：
  - `fout.close();fin.close();`
     - 关闭这样的连接并不会删除流，而只是断开到文件的连接，流管理装置仍被保留。

2. **流状态检查和ios_open()**

   - C++文件流类从ios_base类那里继承了一个流状态成员，<font color=red>该成员存储了指出流状态的信息：一切顺利、已到达文件尾、I/O操作失败等；</font>

     - 如果一切顺利，则流状态为零；

     - 其他状态都是通过将特定位设置为1来记录的；

     - 文件流类还继承了ios_base类中报告流状态的方法，可以通过检查流状态来判断最后一个流操作是否成功，这对于文件流，这包括检查试图打开文件时是否成功；

     - <font color=red>C++提供的检查文件是否被打开的方法——is_open()方法：</font>

       ```C++
       if (!fin.is_open())
       {
       	...
       }
       ```

       <font color=red>这种方法之所以好，是因为它能够检查出其他方式不能检测出的微妙问题。</font>

3. **打开多个文件**

   - 如果需要同时打开两个文件，则必须为每一个文件创建一个流。

4. **命令行处理技术**

5. **文件模式**

   - 文件模式描述的是<font color=red>文件将被如何使用：读、写、追加等；</font>将流与文件关联时，都可以提供指定文件模式的第二个参数；

   - ios_base类定义了一个openmode类型，用于表示模式；她也是一种bitmask类型；可以选择ios_base类中定义的对个常量来指定模式：

     | 常量             | 含义                     |
     | ---------------- | ------------------------ |
     | ios_base::in     | 打开文件，以便读取       |
     | ios_base::out    | 打开文件，以便写入       |
     | ios_base::ate    | 打开文件，并移到文件尾   |
     | ios_base::app    | 追加到文件尾             |
     | ios_base::trunc  | 如果文件存在，则截短文件 |
     | ios_base::binary | 二进制文件               |

   模式的组合：

   1. 追加文件
   2. 二进制文件

6. **随机存取**



## 10.5 内核格式化


